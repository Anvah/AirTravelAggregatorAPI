# AirTravelAggregatorAPI
Сервис для бронирование билетов, кторый аггрегирует данные из двух внешних источников.
Источники имеют разыне API и модели. Для аггрегирования использован Mapster,
как наиболее эффектиыный автоматизированный инструмент для маппинга объектов,
хотя ввиду больших отличий в моделях, разумнее было бы писать его полность вручную,
если стандарты внутри компании и команды это допускают.
Поскольку тербований по архитектуре не было, использована стандартаня 3-х уровневая архитектура. Также на мой взгляд для подобного небольшого сервиса вполне была бы уместна SQRS.
Приложение выполнено как микросервис с внешней авторизацией.
Доступно два метода: на получение списка перелетов с фильтацие и сортировкой и на бронирование
Для получения билетов авторизация не требуется, чтобы любой потенциальный пользователь мог посмотреть перелеты 
прежде чем создавать аккаунт.
Чтобы забронировать билет авторизация уже разумеется нужна.
В сервисе реализован механиз кеширования по средствам MemoryCache. В дальнейшем в зависимости от масштабов системы и требований 
можно заменить данный сервис на распределенное кэширование с помощью Redis.
Для наиболее оптимальной работы кэширования, несмотря на возможность получать уже отфильтрованные данные от источников,
было принято решение запрашивать данные отфильтованные только по дате, и использовать ее в качесте ключа для объекта кэша
Таким образом пользователь сможет просматривая билеты на конкретную дату применять различные фильтры без необходимости снова
отправлять запросы к сервисам с данными и аггрегировать их. В время хранения кэша нужно будет настроить исходя из того, 
как часто оба сервиса могут обновлять данные, или же воспользоваться вебхуками, если сервисы их предоставляют. 
Для возможности отмены запроса для каждого метода API проброшены cancelationToken, а в случе если
один из источников данных слишком долго обрабатывает ответ, запрос автоматически преывается.
На данный момент при таком исходе клиент просто не получет данные из этого источника, при необходимости
можно будет дополнительно обработать каждую ситуацию.
Для обработки ошибок создан ExceptionMeddleware, который на данный момент на каждую ошибку
создает стандартую форму ответа для API и передает в нее информиацию об ошибке. В дальнейшем можно усложнить эту логику 
и обрабатывать каждую ситуацию индивидуально.
Каждый ответ от API обернут в стандартую форму ответа, где есть тело ответа (если нужно),
статус запроса (успешный или нет) и информация об ошибке. Это сделано с целью более удобной обработки на клиенте.
В дальнейшем, если приложение предполагает развитие в виде микросервисной архитектуры данные объекты следует вынести в библиотеку,
и подключать через локальный nuget, чтобы сохранить стандартизацию ответов во всей системе.
